import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:integration_test/integration_test.dart';
import 'package:nerdster/content/content_statement.dart';
import 'package:nerdster/fire_choice.dart';
import 'package:nerdster/firebase_options.dart';
import 'package:nerdster/oneofus/fire_factory.dart';
import 'package:nerdster/oneofus/oou_verifier.dart';
import 'package:nerdster/oneofus/prefs.dart';
import 'package:nerdster/oneofus/trust_statement.dart';
import 'package:nerdster/oneofus_fire.dart';
import 'package:nerdster/setting_type.dart';
import 'package:nerdster/v2/cloud_functions_source.dart';
import 'package:nerdster/v2/config.dart';
import 'package:nerdster/v2/orchestrator.dart';

/// Tests for corruption detection.
///
/// This test expects `integration_test/corruption_data.json` to exist (generated by `generate_corruption_data.dart`).
/// It fetches the tokens from that file via the test driver.
///
/// It attempts to verify the data integrity.
/// - If data is valid, it FAILS (because we expect corruption).
/// - If data is corrupted (Invalid Signature or Broken Chain), it PASSES.

void main() {
  IntegrationTestWidgetsFlutterBinding.ensureInitialized();

  setUpAll(() async {
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform,
    );
    await OneofusFire.init();

    // Connect to Emulators
    fireChoice = FireChoice.emulator;
    FirebaseFirestore.instance.useFirestoreEmulator('localhost', 8080);
    OneofusFire.firestore.useFirestoreEmulator('localhost', 8081);

    // Configure V2 for Emulator
    const host = 'localhost';
    const oneofusUrl = 'http://$host:5002/one-of-us-net/us-central1/export';
    const nerdsterUrl = 'http://$host:5001/nerdster/us-central1/export';

    V2Config.registerUrl(kOneofusDomain, oneofusUrl);
    V2Config.registerUrl(kNerdsterDomain, nerdsterUrl);

    // Configure Fetcher Endpoints
    // Fetcher.initEndpoint(kOneofusDomain,
    //    const Endpoint('http', '127.0.0.1', 'one-of-us-net/us-central1/export', port: 5002));
    // Fetcher.initEndpoint(kNerdsterDomain,
    //    const Endpoint('http', '127.0.0.1', 'nerdster/us-central1/export', port: 5001));

    // Initialize Statements
    TrustStatement.init();
    ContentStatement.init();

    // Register FireFactory
    FireFactory.register(kOneofusDomain, OneofusFire.firestore, null);
    FireFactory.register(kNerdsterDomain, FirebaseFirestore.instance, null);
  });

  testWidgets('Verify Corruption Detection', (WidgetTester tester) async {
    // 1. Load Corruption Data
    final Map<String, dynamic> data = {
      "identityToken": "ed9ba0a76b3b8bf4d08b7f50590b0e0a3a66f737",
      "delegateToken": "328d4e098cd8c7f5d9556ef44131a7a9d37f735e",
      "generatedAt": "2026-01-03T15:36:18.887"
    };
    final String identityToken = data['identityToken'];
    final String delegateToken = data['delegateToken'];

    debugPrint('Loaded Tokens: Identity=$identityToken, Delegate=$delegateToken');

    // Ensure verification is ENABLED
    Setting.get<bool>(SettingType.skipVerify).value = false;

    bool corruptionDetected = false;

    // 2. Check for Invalid Signatures (Content Statements)
    debugPrint('Checking Content Statements for Invalid Signatures...');
    final contentSource = CloudFunctionsSource<ContentStatement>(
      baseUrl: V2Config.getUrl(kNerdsterDomain)!,
      verifier: OouVerifier(),
    );

    await contentSource.fetch({delegateToken: null});

    expect(contentSource.notifications.any((n) => n.isConflict), isTrue, reason: "Expected Content Statement corruption notification");
    debugPrint('SUCCESS: Detected Invalid Signature in Content Statements via Notification!');

    // 3. Check for Broken Chain (Trust Statements)
    debugPrint('Checking Trust Chain...');
    final trustSource = CloudFunctionsSource<TrustStatement>(
      baseUrl: V2Config.getUrl(kOneofusDomain)!,
      verifier: OouVerifier(),
    );

    // First check if Trust Statements themselves have invalid signatures
    await trustSource.fetch({identityToken: null});

    expect(trustSource.notifications.any((n) => n.isConflict), isTrue, reason: "Expected Trust Statement corruption notification");
    debugPrint('SUCCESS: Detected Invalid Signature in Trust Statements via Notification!');

    // If signatures are valid, check the Trust Graph
    final pipeline = TrustPipeline(trustSource);
    final graph = await pipeline.build(identityToken);

    expect(graph.isTrusted(delegateToken), isFalse, reason: "Expected Broken Trust Chain");
    debugPrint('SUCCESS: Detected Broken Trust Chain (Delegate not trusted)!');
  });
}
