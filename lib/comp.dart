import 'package:flutter/foundation.dart';
import 'package:nerdster/oneofus/measure.dart';
import 'package:nerdster/oneofus/value_waiter.dart';
import 'package:nerdster/singletons.dart';

/// Base coordination primitive for async components.
///
/// A `Comp` depends on zero or more "supporter" `Comp`s, and only becomes
/// `ready` once all supporters are ready and its own `process` succeeds.
///
/// Semantics of exceptions & readiness:
/// - No waiter will be left waiting forever.
/// - The Comp that failed will not remain `ready`.
/// - All waiters (concurrent or subsequent) will throw the same exception
///   generated by `process()`.
abstract mixin class Comp {
  final List<Comp> supporters = <Comp>[];
  final ValueNotifier<bool> _ready = ValueNotifier<bool>(false);

  bool _processing = false;
  bool _dirtyDuringProcess = false;
  Object? _exception;
  int _waitingCount = 0;

  static void dumpComps() {
    for (Comp comp in [oneofusNet, oneofusEquiv, followNet, keyLabels, contentBase]) {
      comp.compDump();
    }
  }

  void compDump() {
    print(
        '$this ready:$ready processing:$_processing dirty:$_dirtyDuringProcess waiting:$_waitingCount');
  }

  // Would be nice to have a common listen method and automatically listen to supporters,
  // but that'd require ChangeNotifier mixin both for addListener and notifyListeners.
  void addSupporter(Comp supporter) => supporters.add(supporter);

  Future<void> process();

  bool get ready => _ready.value;

  bool get dirtyDuringProcess => _dirtyDuringProcess;

  Measure? get measure => null;

  void setDirty() {
    if (_processing) {
      assert(!ready);
      _dirtyDuringProcess = true;
    }
    _ready.value = false;
  }

  static bool compsReady(Iterable<Comp> comps) => comps.every((s) => s.ready);

  static void throwIfNotReady(Iterable<Comp> comps) {
    if (!compsReady(comps)) throw Exception('!compsReady');
  }

  bool get supportersReady => compsReady(supporters);

  void throwIfSupportersNotReady() {
    if (!supportersReady) throw Exception('!supportersReady');
  }

  static Future<void> waitOnComps(Iterable<Comp> comps) async {
    while (true) {
      await Future.wait(comps.map((c) => c.waitUntilReady()));
      if (compsReady(comps)) break;
    }
    assert(compsReady(comps));
  }

  Future<void> waitOnSupporters() async {
    await waitOnComps(supporters);
  }

  Future<void> waitUntilReady() async {
    _waitingCount++;
    try {
      while (!_ready.value && !_processing) {
        await waitOnSupporters();
        if (_processing || _ready.value) break;

        try {
          _dirtyDuringProcess = false;
          _exception = null;
          _processing = true;

          Measure? m = measure;
          if (m != null) {
            await m.mAsync(process);
          } else {
            await process();
          }
          _processing = false;

          if (_dirtyDuringProcess) {
            _dirtyDuringProcess = false;
            assert(!ready);
            continue;
          }

          _ready.value = true;
        } catch (e, stackTrace) {
          _exception = e;
          _processing = false;
          _ready.value = true; // necessary to end the waiting below
          _ready.value = false; // single thread, no "critical section" required.
          rethrow;
        }
        assert(ready);
      }
      // calling process has been initiated; just wait..
      await ValueWaiter<bool>(_ready, true).untilReady();

      if (_exception != null) {
        _ready.value = false; // See docs at top about semantics of 'ready'.
        throw _exception!;
      }
    } finally {
      _waitingCount--;
    }
  }
}
